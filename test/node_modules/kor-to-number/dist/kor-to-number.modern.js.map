{"version":3,"file":"kor-to-number.modern.js","sources":["../src/constants.ts","../src/index.ts"],"sourcesContent":["type MAP_TYPE = {\n  [key: string]: number;\n};\ntype ORDERED_MAP_TYPE = [string, number][];\nconst SINO_MAP_ONES: MAP_TYPE = {\n  일: 1,\n  이: 2,\n  삼: 3,\n  사: 4,\n  오: 5,\n  육: 6,\n  륙: 6,\n  칠: 7,\n  팔: 8,\n  구: 9,\n};\nconst SINO_MAP_SMALL: ORDERED_MAP_TYPE = [\n  [\"천\", 1000],\n  [\"백\", 100],\n  [\"십\", 10],\n];\nconst SINO_MAP_LARGE: ORDERED_MAP_TYPE = [\n  [\"양\", 1e28],\n  [\"자\", 1e24],\n  [\"해\", 1e20],\n  [\"경\", 1e16],\n  [\"조\", 1e12],\n  [\"억\", 1e8],\n  [\"만\", 1e4],\n];\nconst NATIVE_MAP_ONES: MAP_TYPE = {\n  하나: 1,\n  둘: 2,\n  셋: 3,\n  넷: 4,\n  다섯: 5,\n  여섯: 6,\n  일곱: 7,\n  여덟: 8,\n  아홉: 9,\n  한: 1,\n  두: 2,\n  세: 3,\n  석: 3,\n  서: 3,\n  네: 4,\n  넉: 4,\n  너: 4,\n  닷: 5,\n  엿: 6,\n};\nconst MAP_TENS: MAP_TYPE = {\n  열: 10,\n  스물: 20,\n  서른: 30,\n  마흔: 40,\n  쉰: 50,\n  예순: 60,\n  일흔: 70,\n  여든: 80,\n  아흔: 90,\n  십: 10,\n  일십: 10,\n  이십: 20,\n  삼삽: 30,\n  사십: 40,\n  오십: 50,\n  육십: 60,\n  륙십: 60,\n  칠십: 70,\n  팔십: 80,\n  구십: 90,\n};\n\nexport {\n  MAP_TYPE,\n  ORDERED_MAP_TYPE,\n  SINO_MAP_ONES,\n  SINO_MAP_SMALL,\n  SINO_MAP_LARGE,\n  NATIVE_MAP_ONES,\n  MAP_TENS,\n};\n","import {\n  MAP_TYPE,\n  ORDERED_MAP_TYPE,\n  SINO_MAP_ONES,\n  SINO_MAP_SMALL,\n  SINO_MAP_LARGE,\n  NATIVE_MAP_ONES,\n  MAP_TENS,\n} from \"./constants.js\";\n\nconst isValid = (x: Analysis) => !isNaN(x.parsed);\n\ntype Analysis = { consumed: string; parsed: number; rest: string };\ntype Analyzer = (word: string) => Analysis[];\n\nfunction unionAnalyzer(...analyzers: Analyzer[]): Analyzer {\n  return (word) => analyzers.flatMap((f) => f(word).filter(isValid));\n}\n\nfunction patternAnalyzer(\n  pattern: RegExp,\n  parser: (x: string) => number\n): Analyzer {\n  return function (word: string): Analysis[] {\n    const match = word.match(pattern);\n    if (match == null) return [];\n    const matched = match[0];\n    const consumed = word.slice(0, matched.length);\n    const parsed = parser(matched);\n    const rest = word.slice(matched.length);\n    return [{ consumed, parsed, rest }];\n  };\n}\n\nconst integerAnalyzer = patternAnalyzer(/^[+-]?\\d+(?:,\\d+)*/, (x) =>\n  Number(x.replace(/,/g, \"\"))\n);\nconst decimalAnalyzer = patternAnalyzer(\n  /^[+-]?(?:\\d+(?:,\\d+)*[.]\\d*|[.]\\d+)/,\n  (x) => Number(x.replace(/,/g, \"\"))\n);\nconst scientificAnalyzer = patternAnalyzer(\n  /^[+-]?(?:\\d+[.]?\\d*|[.]\\d+)e[+-]?\\d+/i,\n  Number\n);\n\nfunction tableAnalyzer(table: MAP_TYPE): Analyzer {\n  return function (word: string): Analysis[] {\n    let analyses = [];\n    for (const key in table) {\n      if (word.slice(0, key.length) === key) {\n        analyses.push({\n          consumed: key,\n          parsed: table[key],\n          rest: word.slice(key.length),\n        });\n      }\n    }\n    return analyses;\n  };\n}\n\ntype Combiner = (cumulative: Analysis) => (update: Analysis) => Analysis;\n\nfunction combineByAddition(cumulative: Analysis) {\n  return function (update: Analysis): Analysis {\n    return {\n      consumed: cumulative.consumed + update.consumed,\n      parsed: cumulative.parsed + update.parsed,\n      rest: update.rest,\n    };\n  };\n}\n\nfunction combineByMultiplication(cumulative: Analysis) {\n  return function (update: Analysis): Analysis {\n    return {\n      consumed: cumulative.consumed + update.consumed,\n      parsed: cumulative.parsed * update.parsed,\n      rest: update.rest,\n    };\n  };\n}\n\nfunction sequentialAnalyzer(\n  analyzers: Analyzer[],\n  combiner: Combiner = combineByAddition,\n  omissible = true\n): Analyzer {\n  function binary(a: Analyzer, b: Analyzer): Analyzer {\n    return function (word: string): Analysis[] {\n      let result = [];\n      if (omissible) result.push(...b(word));\n      for (const analysis of a(word)) {\n        if (omissible) result.push(analysis);\n        if (analysis.rest.length >= word.length)\n          throw Error(\"Infinite Recursion\");\n        result.push(...b(analysis.rest).map(combiner(analysis)));\n      }\n      return result.filter(isValid);\n    };\n  }\n  const empty: Analyzer = (_) => [];\n  return analyzers.length ? analyzers.reduce(binary) : empty;\n}\n\nfunction unitAnalyzer(\n  getGroup: Analyzer,\n  unitName: string,\n  unitValue: number\n): Analyzer {\n  const getUnit = tableAnalyzer({ [unitName]: unitValue });\n  return unionAnalyzer(\n    getUnit,\n    sequentialAnalyzer([getGroup, getUnit], combineByMultiplication, false)\n  );\n}\nfunction groupAnalyzer(\n  unitTable: ORDERED_MAP_TYPE,\n  getGroup: Analyzer,\n  getGroupLast?: Analyzer,\n  trim = false\n): Analyzer {\n  function trimRest(x: Analysis): Analysis {\n    const split = x.rest.match(/^(\\s*)(.*)$/);\n    if (split == null) return x;\n    return {\n      consumed: x.consumed + split[1],\n      parsed: x.parsed,\n      rest: split[2],\n    };\n  }\n  let mappers = unitTable.map((pair) => unitAnalyzer(getGroup, ...pair));\n  if (trim) mappers = mappers.map((f) => (x) => f(x).map(trimRest));\n  return sequentialAnalyzer([...mappers, getGroupLast || getGroup]);\n}\n\nconst sinoAnalyzerSmall = groupAnalyzer(\n  SINO_MAP_SMALL,\n  tableAnalyzer(SINO_MAP_ONES)\n);\nconst sinoAnalyzerLarge = unionAnalyzer(\n  patternAnalyzer(/^영/, (_) => 0),\n  groupAnalyzer(SINO_MAP_LARGE, sinoAnalyzerSmall, undefined, true)\n);\nconst sinoAnalyzerFraction = patternAnalyzer(\n  /^\\s*점\\s*[영일이삼사오육륙칠팔구]+/,\n  function (matched) {\n    const sino = matched.trim().slice(1).trim();\n    const digits = sino\n      .split(\"\")\n      .map((x: string) => SINO_MAP_ONES[x] || \"0\")\n      .join(\"\");\n    return Number(\"0.\" + digits);\n  }\n);\nconst sinoAnalyzer = sequentialAnalyzer([\n  sinoAnalyzerLarge,\n  sinoAnalyzerFraction,\n]);\n\nconst digitAnalyzer = patternAnalyzer(/^[1-9]/, Number);\nconst mixAnalyzerSmall = groupAnalyzer(SINO_MAP_SMALL, digitAnalyzer);\nconst mixAnalyzerLarge = groupAnalyzer(\n  SINO_MAP_LARGE,\n  mixAnalyzerSmall,\n  undefined,\n  true\n);\n\nconst digitsAnalyzerSmall = patternAnalyzer(/^[1-9]\\d{0,3}/, Number);\nconst digitsAnalyzerLarge = groupAnalyzer(\n  SINO_MAP_LARGE,\n  digitsAnalyzerSmall,\n  undefined,\n  true\n);\n\nfunction signAnalyzer(f: Analyzer) {\n  const plus = sequentialAnalyzer(\n    [patternAnalyzer(/^플러스\\s*|^[+](?=\\d)/, (_) => +1), f],\n    combineByMultiplication,\n    false\n  );\n  const minus = sequentialAnalyzer(\n    [patternAnalyzer(/^마이너스\\s*|^[-](?=\\d)/, (_) => -1), f],\n    combineByMultiplication,\n    false\n  );\n  return unionAnalyzer(plus, minus, f);\n}\n\nconst nativeAnalyzerTens = unionAnalyzer(\n  patternAnalyzer(/^스무/, (_) => 20),\n  sequentialAnalyzer([tableAnalyzer(MAP_TENS), tableAnalyzer(NATIVE_MAP_ONES)])\n);\nconst nativeAnalyzerSmall = groupAnalyzer(\n  [\n    [\"천\", 1000],\n    [\"백\", 100],\n  ],\n  tableAnalyzer(SINO_MAP_ONES),\n  nativeAnalyzerTens\n);\nconst nativeAnalyzer = groupAnalyzer(\n  SINO_MAP_LARGE,\n  sinoAnalyzerSmall,\n  nativeAnalyzerSmall,\n  true\n);\n\nfunction getBest(...analyses: (Analysis | null)[]): Analysis | null {\n  let best: Analysis | null = null;\n  for (const analysis of analyses) {\n    if (!analysis) continue;\n    else if (!best) best = analysis;\n    else if (best.rest.length > analysis.rest.length) best = analysis;\n  }\n  return best;\n}\n\ntype formatType = \"숫자\" | \"숫자혼용\" | \"한자어\" | \"순우리말\";\nconst analyzerPool = {\n  숫자: unionAnalyzer(integerAnalyzer, decimalAnalyzer, scientificAnalyzer),\n  숫자혼용: signAnalyzer(unionAnalyzer(mixAnalyzerLarge, digitsAnalyzerLarge)),\n  한자어: signAnalyzer(sinoAnalyzer),\n  순우리말: nativeAnalyzer,\n};\n\nfunction extractNumber(\n  word: string,\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"]\n): [number, string] {\n  word = word.trim();\n  const analyzer = unionAnalyzer(\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\n  );\n  const analyses = analyzer(word);\n  const best = getBest(...analyses);\n  if (best) return [best.parsed, best.rest.trim()];\n  else return [NaN, word];\n}\n\ntype Mapper<T> = (analysis: Analysis) => T | null;\nfunction extractAndProcessNumber<T>(\n  word: string,\n  mapper: Mapper<T>,\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"],\n): T | null {\n  word = word.trim();\n  const analyzer = unionAnalyzer(\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\n  );\n  const analyses = analyzer(word);\n  const mapped = analyses.map(mapper);\n\n  let best: number | null = null;\n  for (let i = 0; i < analyses.length; i++) {\n    if (mapped[i] === null) continue;\n    else if (best === null) best = i;\n    else if (analyses[best].rest.length > analyses[i].rest.length) best = i;\n  }\n  return best !== null ? mapped[best] : null;\n}\n\nexport { extractNumber, Analysis, formatType, extractAndProcessNumber, Mapper };\n"],"names":["SINO_MAP_ONES","일","이","삼","사","오","육","륙","칠","팔","구","SINO_MAP_SMALL","SINO_MAP_LARGE","isValid","x","isNaN","parsed","unionAnalyzer","analyzers","word","flatMap","f","filter","patternAnalyzer","pattern","parser","match","matched","consumed","slice","length","rest","integerAnalyzer","Number","replace","decimalAnalyzer","scientificAnalyzer","tableAnalyzer","table","analyses","key","push","combineByAddition","cumulative","update","combineByMultiplication","sequentialAnalyzer","combiner","omissible","reduce","a","b","result","analysis","Error","map","_","groupAnalyzer","unitTable","getGroup","getGroupLast","trim","trimRest","split","mappers","pair","unitName","unitValue","getUnit","unitAnalyzer","sinoAnalyzerSmall","sinoAnalyzer","undefined","digits","join","mixAnalyzerSmall","mixAnalyzerLarge","digitsAnalyzerLarge","signAnalyzer","nativeAnalyzerTens","열","스물","서른","마흔","쉰","예순","일흔","여든","아흔","십","일십","이십","삼삽","사십","오십","육십","륙십","칠십","팔십","구십","하나","둘","셋","넷","다섯","여섯","일곱","여덟","아홉","한","두","세","석","서","네","넉","너","닷","엿","nativeAnalyzerSmall","nativeAnalyzer","analyzerPool","숫자","숫자혼용","한자어","순우리말","extractNumber","format","best","getBest","analyzer","NaN","extractAndProcessNumber","mapper","mapped","i"],"mappings":"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"}