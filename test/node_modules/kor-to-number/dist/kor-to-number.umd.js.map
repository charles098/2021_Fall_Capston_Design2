{"version":3,"file":"kor-to-number.umd.js","sources":["../src/constants.ts","../src/index.ts"],"sourcesContent":["type MAP_TYPE = {\n  [key: string]: number;\n};\ntype ORDERED_MAP_TYPE = [string, number][];\nconst SINO_MAP_ONES: MAP_TYPE = {\n  일: 1,\n  이: 2,\n  삼: 3,\n  사: 4,\n  오: 5,\n  육: 6,\n  륙: 6,\n  칠: 7,\n  팔: 8,\n  구: 9,\n};\nconst SINO_MAP_SMALL: ORDERED_MAP_TYPE = [\n  [\"천\", 1000],\n  [\"백\", 100],\n  [\"십\", 10],\n];\nconst SINO_MAP_LARGE: ORDERED_MAP_TYPE = [\n  [\"양\", 1e28],\n  [\"자\", 1e24],\n  [\"해\", 1e20],\n  [\"경\", 1e16],\n  [\"조\", 1e12],\n  [\"억\", 1e8],\n  [\"만\", 1e4],\n];\nconst NATIVE_MAP_ONES: MAP_TYPE = {\n  하나: 1,\n  둘: 2,\n  셋: 3,\n  넷: 4,\n  다섯: 5,\n  여섯: 6,\n  일곱: 7,\n  여덟: 8,\n  아홉: 9,\n  한: 1,\n  두: 2,\n  세: 3,\n  석: 3,\n  서: 3,\n  네: 4,\n  넉: 4,\n  너: 4,\n  닷: 5,\n  엿: 6,\n};\nconst MAP_TENS: MAP_TYPE = {\n  열: 10,\n  스물: 20,\n  서른: 30,\n  마흔: 40,\n  쉰: 50,\n  예순: 60,\n  일흔: 70,\n  여든: 80,\n  아흔: 90,\n  십: 10,\n  일십: 10,\n  이십: 20,\n  삼삽: 30,\n  사십: 40,\n  오십: 50,\n  육십: 60,\n  륙십: 60,\n  칠십: 70,\n  팔십: 80,\n  구십: 90,\n};\n\nexport {\n  MAP_TYPE,\n  ORDERED_MAP_TYPE,\n  SINO_MAP_ONES,\n  SINO_MAP_SMALL,\n  SINO_MAP_LARGE,\n  NATIVE_MAP_ONES,\n  MAP_TENS,\n};\n","import {\n  MAP_TYPE,\n  ORDERED_MAP_TYPE,\n  SINO_MAP_ONES,\n  SINO_MAP_SMALL,\n  SINO_MAP_LARGE,\n  NATIVE_MAP_ONES,\n  MAP_TENS,\n} from \"./constants.js\";\n\nconst isValid = (x: Analysis) => !isNaN(x.parsed);\n\ntype Analysis = { consumed: string; parsed: number; rest: string };\ntype Analyzer = (word: string) => Analysis[];\n\nfunction unionAnalyzer(...analyzers: Analyzer[]): Analyzer {\n  return (word) => analyzers.flatMap((f) => f(word).filter(isValid));\n}\n\nfunction patternAnalyzer(\n  pattern: RegExp,\n  parser: (x: string) => number\n): Analyzer {\n  return function (word: string): Analysis[] {\n    const match = word.match(pattern);\n    if (match == null) return [];\n    const matched = match[0];\n    const consumed = word.slice(0, matched.length);\n    const parsed = parser(matched);\n    const rest = word.slice(matched.length);\n    return [{ consumed, parsed, rest }];\n  };\n}\n\nconst integerAnalyzer = patternAnalyzer(/^[+-]?\\d+(?:,\\d+)*/, (x) =>\n  Number(x.replace(/,/g, \"\"))\n);\nconst decimalAnalyzer = patternAnalyzer(\n  /^[+-]?(?:\\d+(?:,\\d+)*[.]\\d*|[.]\\d+)/,\n  (x) => Number(x.replace(/,/g, \"\"))\n);\nconst scientificAnalyzer = patternAnalyzer(\n  /^[+-]?(?:\\d+[.]?\\d*|[.]\\d+)e[+-]?\\d+/i,\n  Number\n);\n\nfunction tableAnalyzer(table: MAP_TYPE): Analyzer {\n  return function (word: string): Analysis[] {\n    let analyses = [];\n    for (const key in table) {\n      if (word.slice(0, key.length) === key) {\n        analyses.push({\n          consumed: key,\n          parsed: table[key],\n          rest: word.slice(key.length),\n        });\n      }\n    }\n    return analyses;\n  };\n}\n\ntype Combiner = (cumulative: Analysis) => (update: Analysis) => Analysis;\n\nfunction combineByAddition(cumulative: Analysis) {\n  return function (update: Analysis): Analysis {\n    return {\n      consumed: cumulative.consumed + update.consumed,\n      parsed: cumulative.parsed + update.parsed,\n      rest: update.rest,\n    };\n  };\n}\n\nfunction combineByMultiplication(cumulative: Analysis) {\n  return function (update: Analysis): Analysis {\n    return {\n      consumed: cumulative.consumed + update.consumed,\n      parsed: cumulative.parsed * update.parsed,\n      rest: update.rest,\n    };\n  };\n}\n\nfunction sequentialAnalyzer(\n  analyzers: Analyzer[],\n  combiner: Combiner = combineByAddition,\n  omissible = true\n): Analyzer {\n  function binary(a: Analyzer, b: Analyzer): Analyzer {\n    return function (word: string): Analysis[] {\n      let result = [];\n      if (omissible) result.push(...b(word));\n      for (const analysis of a(word)) {\n        if (omissible) result.push(analysis);\n        if (analysis.rest.length >= word.length)\n          throw Error(\"Infinite Recursion\");\n        result.push(...b(analysis.rest).map(combiner(analysis)));\n      }\n      return result.filter(isValid);\n    };\n  }\n  const empty: Analyzer = (_) => [];\n  return analyzers.length ? analyzers.reduce(binary) : empty;\n}\n\nfunction unitAnalyzer(\n  getGroup: Analyzer,\n  unitName: string,\n  unitValue: number\n): Analyzer {\n  const getUnit = tableAnalyzer({ [unitName]: unitValue });\n  return unionAnalyzer(\n    getUnit,\n    sequentialAnalyzer([getGroup, getUnit], combineByMultiplication, false)\n  );\n}\nfunction groupAnalyzer(\n  unitTable: ORDERED_MAP_TYPE,\n  getGroup: Analyzer,\n  getGroupLast?: Analyzer,\n  trim = false\n): Analyzer {\n  function trimRest(x: Analysis): Analysis {\n    const split = x.rest.match(/^(\\s*)(.*)$/);\n    if (split == null) return x;\n    return {\n      consumed: x.consumed + split[1],\n      parsed: x.parsed,\n      rest: split[2],\n    };\n  }\n  let mappers = unitTable.map((pair) => unitAnalyzer(getGroup, ...pair));\n  if (trim) mappers = mappers.map((f) => (x) => f(x).map(trimRest));\n  return sequentialAnalyzer([...mappers, getGroupLast || getGroup]);\n}\n\nconst sinoAnalyzerSmall = groupAnalyzer(\n  SINO_MAP_SMALL,\n  tableAnalyzer(SINO_MAP_ONES)\n);\nconst sinoAnalyzerLarge = unionAnalyzer(\n  patternAnalyzer(/^영/, (_) => 0),\n  groupAnalyzer(SINO_MAP_LARGE, sinoAnalyzerSmall, undefined, true)\n);\nconst sinoAnalyzerFraction = patternAnalyzer(\n  /^\\s*점\\s*[영일이삼사오육륙칠팔구]+/,\n  function (matched) {\n    const sino = matched.trim().slice(1).trim();\n    const digits = sino\n      .split(\"\")\n      .map((x: string) => SINO_MAP_ONES[x] || \"0\")\n      .join(\"\");\n    return Number(\"0.\" + digits);\n  }\n);\nconst sinoAnalyzer = sequentialAnalyzer([\n  sinoAnalyzerLarge,\n  sinoAnalyzerFraction,\n]);\n\nconst digitAnalyzer = patternAnalyzer(/^[1-9]/, Number);\nconst mixAnalyzerSmall = groupAnalyzer(SINO_MAP_SMALL, digitAnalyzer);\nconst mixAnalyzerLarge = groupAnalyzer(\n  SINO_MAP_LARGE,\n  mixAnalyzerSmall,\n  undefined,\n  true\n);\n\nconst digitsAnalyzerSmall = patternAnalyzer(/^[1-9]\\d{0,3}/, Number);\nconst digitsAnalyzerLarge = groupAnalyzer(\n  SINO_MAP_LARGE,\n  digitsAnalyzerSmall,\n  undefined,\n  true\n);\n\nfunction signAnalyzer(f: Analyzer) {\n  const plus = sequentialAnalyzer(\n    [patternAnalyzer(/^플러스\\s*|^[+](?=\\d)/, (_) => +1), f],\n    combineByMultiplication,\n    false\n  );\n  const minus = sequentialAnalyzer(\n    [patternAnalyzer(/^마이너스\\s*|^[-](?=\\d)/, (_) => -1), f],\n    combineByMultiplication,\n    false\n  );\n  return unionAnalyzer(plus, minus, f);\n}\n\nconst nativeAnalyzerTens = unionAnalyzer(\n  patternAnalyzer(/^스무/, (_) => 20),\n  sequentialAnalyzer([tableAnalyzer(MAP_TENS), tableAnalyzer(NATIVE_MAP_ONES)])\n);\nconst nativeAnalyzerSmall = groupAnalyzer(\n  [\n    [\"천\", 1000],\n    [\"백\", 100],\n  ],\n  tableAnalyzer(SINO_MAP_ONES),\n  nativeAnalyzerTens\n);\nconst nativeAnalyzer = groupAnalyzer(\n  SINO_MAP_LARGE,\n  sinoAnalyzerSmall,\n  nativeAnalyzerSmall,\n  true\n);\n\nfunction getBest(...analyses: (Analysis | null)[]): Analysis | null {\n  let best: Analysis | null = null;\n  for (const analysis of analyses) {\n    if (!analysis) continue;\n    else if (!best) best = analysis;\n    else if (best.rest.length > analysis.rest.length) best = analysis;\n  }\n  return best;\n}\n\ntype formatType = \"숫자\" | \"숫자혼용\" | \"한자어\" | \"순우리말\";\nconst analyzerPool = {\n  숫자: unionAnalyzer(integerAnalyzer, decimalAnalyzer, scientificAnalyzer),\n  숫자혼용: signAnalyzer(unionAnalyzer(mixAnalyzerLarge, digitsAnalyzerLarge)),\n  한자어: signAnalyzer(sinoAnalyzer),\n  순우리말: nativeAnalyzer,\n};\n\nfunction extractNumber(\n  word: string,\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"]\n): [number, string] {\n  word = word.trim();\n  const analyzer = unionAnalyzer(\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\n  );\n  const analyses = analyzer(word);\n  const best = getBest(...analyses);\n  if (best) return [best.parsed, best.rest.trim()];\n  else return [NaN, word];\n}\n\ntype Mapper<T> = (analysis: Analysis) => T | null;\nfunction extractAndProcessNumber<T>(\n  word: string,\n  mapper: Mapper<T>,\n  format: formatType[] = [\"숫자\", \"숫자혼용\", \"한자어\", \"순우리말\"],\n): T | null {\n  word = word.trim();\n  const analyzer = unionAnalyzer(\n    ...format.map((key) => analyzerPool[key]).filter((x) => x)\n  );\n  const analyses = analyzer(word);\n  const mapped = analyses.map(mapper);\n\n  let best: number | null = null;\n  for (let i = 0; i < analyses.length; i++) {\n    if (mapped[i] === null) continue;\n    else if (best === null) best = i;\n    else if (analyses[best].rest.length > analyses[i].rest.length) best = i;\n  }\n  return best !== null ? mapped[best] : null;\n}\n\nexport { extractNumber, Analysis, formatType, extractAndProcessNumber, Mapper };\n"],"names":["SINO_MAP_ONES","일","이","삼","사","오","육","륙","칠","팔","구","SINO_MAP_SMALL","SINO_MAP_LARGE","isValid","x","isNaN","parsed","unionAnalyzer","word","flatMap","f","filter","patternAnalyzer","pattern","parser","match","matched","consumed","slice","length","rest","integerAnalyzer","Number","replace","decimalAnalyzer","scientificAnalyzer","tableAnalyzer","table","analyses","key","push","combineByAddition","cumulative","update","combineByMultiplication","sequentialAnalyzer","analyzers","combiner","omissible","reduce","a","b","result","analysis","Error","map","_","unitAnalyzer","getGroup","unitName","unitValue","getUnit","groupAnalyzer","unitTable","getGroupLast","trim","trimRest","split","mappers","pair","sinoAnalyzerSmall","sinoAnalyzer","undefined","digits","join","mixAnalyzerSmall","mixAnalyzerLarge","digitsAnalyzerLarge","signAnalyzer","nativeAnalyzerTens","열","스물","서른","마흔","쉰","예순","일흔","여든","아흔","십","일십","이십","삼삽","사십","오십","육십","륙십","칠십","팔십","구십","하나","둘","셋","넷","다섯","여섯","일곱","여덟","아홉","한","두","세","석","서","네","넉","너","닷","엿","nativeAnalyzerSmall","nativeAnalyzer","getBest","best","analyzerPool","숫자","숫자혼용","한자어","순우리말","mapper","format","analyzer","mapped","i","NaN"],"mappings":"2hCAIA,IAAMA,EAA0B,CAC9BC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,GAECC,EAAmC,CACvC,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,KAEFC,EAAmC,CACvC,CAAC,IAAK,MACN,CAAC,IAAK,MACN,CAAC,IAAK,MACN,CAAC,IAAK,MACN,CAAC,IAAK,MACN,CAAC,IAAK,KACN,CAAC,IAAK,MClBFC,EAAU,SAACC,UAAiBC,MAAMD,EAAEE,SAK1C,SAASC,oBACP,gBAAQC,SAAS,iBAAUC,QAAQ,SAACC,UAAMA,EAAEF,GAAMG,OAAOR,MAG3D,SAASS,EACPC,EACAC,GAEA,gBAAiBN,GACf,IAAMO,EAAQP,EAAKO,MAAMF,GACzB,GAAa,MAATE,EAAe,MAAO,GAC1B,IAAMC,EAAUD,EAAM,GAItB,MAAO,CAAC,CAAEE,SAHOT,EAAKU,MAAM,EAAGF,EAAQG,QAGnBb,OAFLQ,EAAOE,GAEMI,KADfZ,EAAKU,MAAMF,EAAQG,WAKpC,IAAME,EAAkBT,EAAgB,qBAAsB,SAACR,UAC7DkB,OAAOlB,EAAEmB,QAAQ,KAAM,OAEnBC,EAAkBZ,EACtB,sCACA,SAACR,UAAMkB,OAAOlB,EAAEmB,QAAQ,KAAM,OAE1BE,EAAqBb,EACzB,wCACAU,QAGF,SAASI,EAAcC,GACrB,gBAAiBnB,GACf,IAAIoB,EAAW,GACf,IAAK,IAAMC,KAAOF,EACZnB,EAAKU,MAAM,EAAGW,EAAIV,UAAYU,GAChCD,EAASE,KAAK,CACZb,SAAUY,EACVvB,OAAQqB,EAAME,GACdT,KAAMZ,EAAKU,MAAMW,EAAIV,UAI3B,OAAOS,GAMX,SAASG,EAAkBC,GACzB,gBAAiBC,GACf,MAAO,CACLhB,SAAUe,EAAWf,SAAWgB,EAAOhB,SACvCX,OAAQ0B,EAAW1B,OAAS2B,EAAO3B,OACnCc,KAAMa,EAAOb,OAKnB,SAASc,EAAwBF,GAC/B,gBAAiBC,GACf,MAAO,CACLhB,SAAUe,EAAWf,SAAWgB,EAAOhB,SACvCX,OAAQ0B,EAAW1B,OAAS2B,EAAO3B,OACnCc,KAAMa,EAAOb,OAKnB,SAASe,EACPC,EACAC,EACAC,GAgBA,gBAjBAD,IAAAA,EAAqBN,YACrBO,IAAAA,GAAY,GAgBLF,EAAUjB,OAASiB,EAAUG,OAdpC,SAAgBC,EAAaC,GAC3B,gBAAiBjC,GACf,IAAIkC,EAAS,GACTJ,GAAWI,EAAOZ,WAAPY,EAAeD,EAAEjC,IAChC,cAAuBgC,EAAEhC,mBAAO,KAArBmC,UAET,GADIL,GAAWI,EAAOZ,KAAKa,GACvBA,EAASvB,KAAKD,QAAUX,EAAKW,OAC/B,MAAMyB,MAAM,sBACdF,EAAOZ,WAAPY,EAAeD,EAAEE,EAASvB,MAAMyB,IAAIR,EAASM,KAE/C,OAAOD,EAAO/B,OAAOR,MAGD,SAAC2C,SAAM,IAIjC,SAASC,EACPC,EACAC,EACAC,SAEMC,EAAUzB,UAAiBuB,GAAWC,MAC5C,OAAO3C,EACL4C,EACAhB,EAAmB,CAACa,EAAUG,GAAUjB,GAAyB,IAGrE,SAASkB,EACPC,EACAL,EACAM,EACAC,GAEA,SAASC,EAASpD,GAChB,IAAMqD,EAAQrD,EAAEgB,KAAKL,MAAM,eAC3B,OAAa,MAAT0C,EAAsBrD,EACnB,CACLa,SAAUb,EAAEa,SAAWwC,EAAM,GAC7BnD,OAAQF,EAAEE,OACVc,KAAMqC,EAAM,aARhBF,IAAAA,GAAO,GAWP,IAAIG,EAAUL,EAAUR,IAAI,SAACc,UAASZ,gBAAaC,UAAaW,MAEhE,OADIJ,IAAMG,EAAUA,EAAQb,IAAI,SAACnC,mBAAON,UAAMM,EAAEN,GAAGyC,IAAIW,OAChDrB,YAAuBuB,GAASJ,GAAgBN,KAGzD,IAAMY,EAAoBR,EACxBnD,EACAyB,EAAcpC,IAiBVuE,EAAe1B,EAAmB,CAfd5B,EACxBK,EAAgB,KAAM,SAACkC,cACvBM,EAAclD,EAAgB0D,OAAmBE,GAAW,IAEjClD,EAC3B,yBACA,SAAUI,GACR,IACM+C,EADO/C,EAAQuC,OAAOrC,MAAM,GAAGqC,OAElCE,MAAM,IACNZ,IAAI,SAACzC,UAAcd,EAAcc,IAAM,MACvC4D,KAAK,IACR,OAAO1C,OAAO,KAAOyC,OASnBE,EAAmBb,EAAcnD,EADjBW,EAAgB,SAAUU,SAE1C4C,EAAmBd,EACvBlD,EACA+D,OACAH,GACA,GAIIK,EAAsBf,EAC1BlD,EAF0BU,EAAgB,gBAAiBU,aAI3DwC,GACA,GAGF,SAASM,EAAa1D,GAWpB,OAAOH,EAVM4B,EACX,CAACvB,EAAgB,qBAAsB,SAACkC,UAAM,IAAKpC,GACnDwB,GACA,GAEYC,EACZ,CAACvB,EAAgB,sBAAuB,SAACkC,UAAO,IAAIpC,GACpDwB,GACA,GAEgCxB,GAGpC,IAAM2D,EAAqB9D,EACzBK,EAAgB,MAAO,SAACkC,eACxBX,EAAmB,CAACT,ED/IK,CACzB4C,IAAG,GACHC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,IAAG,GACHC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,IAAG,GACHC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,GACJC,KAAI,KC2HyC/D,EDpKb,CAChCgE,KAAI,EACJC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,KAAI,EACJC,KAAI,EACJC,KAAI,EACJC,KAAI,EACJC,KAAI,EACJC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,EACHC,IAAG,OCmJCC,EAAsBzD,EAC1B,CACE,CAAC,IAAK,KACN,CAAC,IAAK,MAER1B,EAAcpC,GACd+E,GAEIyC,EAAiB1D,EACrBlD,EACA0D,EACAiD,GACA,GAGF,SAASE,IAEP,IADA,MAAIC,EAAwB,kDACK,KAAtBrE,UACJA,IACKqE,EACDA,EAAK5F,KAAKD,OAASwB,EAASvB,KAAKD,SAAQ6F,EAAOrE,GADzCqE,EAAOrE,GAGzB,OAAOqE,EAIT,IAAMC,EAAe,CACnBC,KAAI3G,EAAcc,EAAiBG,EAAiBC,GACpD0F,OAAM/C,EAAa7D,EAAc2D,EAAkBC,IACnDiD,MAAKhD,EAAaP,GAClBwD,OAAMP,6BAkBR,SACEtG,EACA8G,EACAC,YAAAA,IAAAA,EAAuB,CAAC,KAAM,OAAQ,MAAO,SAE7C/G,EAAOA,EAAK+C,OAQZ,IAPA,IAGM3B,EAHWrB,eACZgH,EAAO1E,IAAI,SAAChB,UAAQoF,EAAapF,KAAMlB,OAAO,SAACP,UAAMA,IAEzCoH,CAAShH,GACpBiH,EAAS7F,EAASiB,IAAIyE,GAExBN,EAAsB,KACjBU,EAAI,EAAGA,EAAI9F,EAAST,OAAQuG,IACjB,OAAdD,EAAOC,KACO,OAATV,GACApF,EAASoF,GAAM5F,KAAKD,OAASS,EAAS8F,GAAGtG,KAAKD,UAD/B6F,EAAOU,GAGjC,OAAgB,OAATV,EAAgBS,EAAOT,GAAQ,sBAjCxC,SACExG,EACA+G,YAAAA,IAAAA,EAAuB,CAAC,KAAM,OAAQ,MAAO,SAE7C/G,EAAOA,EAAK+C,OACZ,IAGM3B,EAHWrB,eACZgH,EAAO1E,IAAI,SAAChB,UAAQoF,EAAapF,KAAMlB,OAAO,SAACP,UAAMA,IAEzCoH,CAAShH,GACpBwG,EAAOD,eAAWnF,GACxB,OAAIoF,EAAa,CAACA,EAAK1G,OAAQ0G,EAAK5F,KAAKmC,QAC7B,CAACoE,IAAKnH"}